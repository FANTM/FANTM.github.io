{
    "componentChunkName": "component---src-templates-documentation-template-jsx",
    "path": "/DEVLPR/software/libdevlpr",
    "result": {"data":{"site":{"siteMetadata":{"siteUrl":"https://FANTM.github.io"}},"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"/DEVLPR/software/libdevlpr\",\n  \"date\": \"2021-07-26\",\n  \"title\": \"Libdevlpr\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar InternalLink = makeShortcode(\"InternalLink\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Current Version: 0.2.1\")), mdx(\"h2\", null, \"Overview\"), mdx(\"p\", null, \"Libdevlpr is the Arduino API for the FANTM DEVLPR.\\nIt's primarily for interacting connecting the FANTM DEVLPR to other hardware based projects running off the Arduino (e.g. controlling LEDs and motors).\\nFor connecting the DEVLPR to a software project (e.g. connecting it to a game), see \", mdx(InternalLink, {\n    to: \"/DEVLPR/software/devlprd\",\n    mdxType: \"InternalLink\"\n  }, \"devlprd\"), \".\"), mdx(\"p\", null, \"Libdevlpr is mainly callback oriented, allowing you to call a function at a fixed frequency, and use the incoming EMG data easily.\\nIt also gives you access to very basic data processing and filtering that can run on the Arduino, and primative flex detection.\"), mdx(\"p\", null, \"The library is open-source and can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/FANTM/libdevlpr\"\n  }, \"here\"), \".\"), mdx(\"h2\", null, \"Installation\"), mdx(\"p\", null, \"Libdevlpr can be installed through Arduino's very own library manager. Just navigate to \\\"Tools/Manage Libraries...\\\" or press \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ctrl-shift-i\"), \", and then search \\\"libdevlpr\\\".\\nAfter pressing the install button, all that is left is putting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#include <Libdevlpr.h>\"), \" at the top of the sketch.\"), mdx(\"h2\", null, \"API\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"#define\"), \" \", mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"FILTER_NONE\"), \" 0\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Uses no filter, ensuring that functions in the API return raw data\")), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"#define\"), \" \", mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"FILTER_50HZ\"), \" 1\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Filters out the 50 Hz band of the signal, removing power line noise. Use this if you are based in a country where the grid operates at 50 Hz (e.g. most of Europe).\")), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"#define\"), \" \", mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"FILTER_60HZ\"), \" 2\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Filters out the 60 Hz band of the signal, removing power line noise. Use this if you are based in a country where the grid operates at 60 Hz (e.g. the USA)\")), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"class\"), \" \", mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Devlpr\"), \"(\", mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"pin=A0, int filterType=FILTER_NONE\"), \")\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This class is a a one-to-one mapping for each DEVLPR shield plugged into the Arduino.\\nIt is the parent of all of the filtering and callback logic in the library. \")), mdx(\"blockquote\", null, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"pin\"), \" indicates the analog pin the DEVLPR is connected to.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"filterType\"), \" parameter expects one of the #define'd filters, and will use that filter when fetching any data.\"))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"void\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"tick\"), \"()\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Reads a new EMG value into the buffer and checks if any callbacks should be called.\\nA core part of the library, it almost always needs to be called in the Arduino \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"void loop()\"), \" function on every loop regardless of application.\\nThis ensures the freshest data is in the buffer, and that nothing is missed.\"))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"unsigned int\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"lastValue\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"bool filtered=false\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Gets the most recent value in the EMG buffer. \"))), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"filtered\"), \" causes the function to filter the data using the filter type defined when the Devlpr object was constructed.\")))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"int\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"lastValueCentered\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"bool filtered=false\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Gets the most recent value in the EMG buffer, and then subtracts the average across the buffer. In effect a DC removal filter.\"))), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"filtered\"), \" causes the function to filter the data using the filter type defined when the Devlpr object was constructed.\")))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"unsigned int\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"windowAvg\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"bool filtered=false\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Gets the average of all readings in the EMG buffer.\"))), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"filtered\"), \" causes the function to filter the data using the filter type defined when the Devlpr object was constructed.\")))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"unsigned int\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"windowPeakAmplitude\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"bool filtered=false\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Gets the difference between the midpoint of the EMG buffer (the DC offset) and the highest point in the buffer.\"))), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"filtered\"), \" causes the function to filter the data using the filter type defined when the Devlpr object was constructed.\")))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"unsigned int\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"windowPeakToPeakAmplitude\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"bool filtered=false\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Gets the difference between the lowest and highest value in the EMG buffer.\\nUsually the most reliable way to get a high signal-to-noise representation of a muscle contraction.\"))), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"filtered\"), \" causes the function to filter the data using the filter type defined when the Devlpr object was constructed.\")))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"int\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"scheduleFunction\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"void (\", \"*\", \"f)(Devlpr \", \"*\", \"d), unsigned int millisPer\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Set a function to be called at some millisecond interval. The function accept a pointer to the Devlpr object as its sole arguement. \"))), mdx(\"blockquote\", null, mdx(\"h5\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"void\"), \" Devlpr::\", mdx(\"strong\", {\n    parentName: \"h5\"\n  }, \"setFlexCallback\"), \"(\", mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"void (\", \"*\", \"f)(Devlpr \", \"*\", \"d), float threshMult=1.5, unsigned int millisCooldown=400\"), \")\")), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Set a function to be called whenever a flex is detected. The function accept a pointer to the Devlpr object as its sole arguement.\\nThis function almost always needs to be tuned to the specific application via modification to its threshMult and millisCooldown;\\nalways do software tuning before using a screwdriver to adjust the gain.\"))), mdx(\"blockquote\", null, mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"threshMult\"), \" allows for tuning how sensitive the flex detection is, adjusting how hard a flex has to be to be detected.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"millisCooldown\"), \" is for debouncing the detection, to reduce the chance that a single muscle contraction is double counted.\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"slug":"/DEVLPR/software/libdevlpr","title":"Libdevlpr","date":"July 26, 2021"}}},"pageContext":{"slug":"/DEVLPR/software/libdevlpr"}},
    "staticQueryHashes": ["3135763025"]}